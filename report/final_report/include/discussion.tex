
The model has been implemented in an iterative way. Function for function,
requirement for requirement. This process is very easy with the use of
QuickCheck.
In the beginning there were alot of negative testing, because we didn't care
about tweaking the generators.
Sometimes the model needs to be corrected because of ambiguities in AUTOSAR or
errors in the model. Quite often it was the C-code that had the errors and
needed to be corrected.
Easier when you do white box testing, when the source code is known,
because then you can really check the code and compare with the requirements.

The C-code coverage was measured differently from the Erlang code
coverage, which used line coverage instead of condition/decision
coverage. Recursion is often used in functional programming languages
as Erlang, therefore it is not as suited for condition/decision
coverage as C-code is. Erlang also comes with a coverage library,
which makes it easy to use. On the other hand, measuring line coverage
in a imperative language like C is a bit redundant since statements
are executed sequentially. Therefore conditions/decision coverage
seems more reasonable.

We achieved fair coverage of the C-code, around 85\%, and the Erlang
code, around 97\%. The problem was the requirements, where we achieved
around 50\%. It would help if a QuickCheck model was implemented for
the whole system as well. Many of the requirements had dependencies in
other modules, and some requirements for the file structure, the
configuration or even the generation of files.

QuickCheck is good for overall testing, and can help with raising the functional
safety of modules.

%% analys av resultat
%% - coverage på modell och c-kod genom cover (erlang) och bullseye (c-kod)
%% - statistik på quickcheck körningar.

Stripped of comments and blank lines, the implemented Erlang model is
almost 1300 lines of code. This is to be compared with the C-code
which is over 14500 lines of code.
%% cat src/* inc/* generated_cfg/*.[c,h] stub/* rte/* gcc/* | grep -vP
%% ^[[:space:]]?'/\*' | grep -vP ^[[:space:]]?'\*' | grep -vP
%% ^[[:space:]]?'\\\*' | grep -v ^[[:space:]]$ | wc -l


\section{Future work}
Some interesting thing we wanted to do from the beginning was to implementing
another module, preferably one that has some kind of dependency with the
watchdog manager. This is because then, it would be possible to testing towards
the phase ``system integration and testing'' in ISO~26262 and get even better
results.

Another good idea is to do more negative testing, and testing of null
pointers. This should be done to raise the coverage for the C-code to even
better levels.

We could also try new configurations. More configurations = better testing.