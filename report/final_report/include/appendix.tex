\chapter{Introductions to QuickCheck}
\label{APP:QUICKCHECK}
\lstset{style=erlang}
\label{SEC:QuickCheckIntro}

\section{The General Idea}
The general idea, with QuickCheck, is here explained using an example.
Lets say that one has a \emph{sort} function that takes a list $Xs$ of any
sortable items and returns the sorted version $Ys$ of $Xs$. To verify the
correctness of this function it is possible to look at certain properties
that must hold for a correctly implemented sort function. For instance:

\noindent The arity of $Y$ must be the same.
\begin{equation}
        |Xs| = |Ys|
\end{equation}

\noindent The elements of $Ys$ must actually be sorted.
\begin{equation}
    y_{i-1} \leq y_i, \forall y_i \in Ys, i \neq 0
\end{equation}

\noindent For all permutations $Pe(Xs)$ holds:
\begin{equation}
sort(Zs) = Ys, \forall Zs \in Pe(Xs)
\end{equation}

\noindent The sets $Xs$ and $Ys$ contains the same elements.
\begin{equation}
        x \in Xs \leftrightarrow x \in Ys
\end{equation}
Instead of specifying own test cases QuickCheck makes it possible to write such
properties, automatically generates test cases and checks that the properties
specified actually holds.

\section{Testing C-code}
QuickCheck is a testing tool for the programming language Erlang, but it is
possible to efficiently test C-code, using QuickCheck, by performing API-calls
against the C-code within Erlang.  Lets say that there is a \emph{Queue}
implementation in C that has a function for creating a new queue as well
as functions for inserting and retrieving elements from a queue structure.

\begin{lstlisting}[style=c]
typedef struct
{
   int size;
   int head;
   int tail;
   int* buffer;
} Queue;

Queue* new(int size) { ... }
int put(Queue* q, int element) { ... }
int get(Queue* q) { ... }
\end{lstlisting}
This program has a number of properties that should hold. For
instance:
\begin{itemize}
\item When creating a new queue, the C function should return an
address to the memory where it have allocated space.
\item The function \lstinline!put! should insert the element into the queue
and return the element.
\item It should be possible to dequeue an element in the order it was
inserted with the function \lstinline!get!.
\end{itemize}
Such properties can be used when using QuickCheck.
%Instead of specifying own test cases QuickCheck makes it possible to
%write such properties, automatically generates test cases and checks
%that the properties specified actually holds.

When testing C code with QuickCheck one uses state based
testing. Which means that a model state $S$ is passed around and
checked against API calls according to figure \ref{FIG:API_CALLS}.

\begin{figure}[!h]
  \includegraphics{pictures/api_calls.jpg}
  \caption{Shows state based testing against API and model state}
  \label{FIG:API_CALLS}
\end{figure}
First a model of the queue must be implemented in Erlang code.
It is also needed to implement a representation of the current state of the queue.

\begin{lstlisting}
-record(state, {ptr, queue}).

new_next(_S, Pointer, _) ->
   #state{ptr=Pointer, queue=[]}.
put_next(S, _, [_, X]) ->
   S#state{queue = S#state.queue++[X]}.
get_next(S, _, _) ->
   S#state{queue = tl(S#state.queue)}.
\end{lstlisting}

The \lstinline!record! will contain information needed to successfully
test the states of the program. It has two variables;
\emph{ptr} which is the pointer to the queue and
\emph{queue} which is a list defining all inserted elements in the queue.

QuickCheck must also be told how to call the C-functions.
\begin{lstlisting}
new(Size) ->
  q:new(Size).
put(Ptr, Val) ->
  q:put(Ptr, Val).
get(Ptr) ->
  q:get(Ptr).
\end{lstlisting}

Now the postconditions, program properties that must hold, are defined.
\begin{lstlisting}
new_post(_S, _Arguments, ReturnValue) ->
  case ReturnValue of
    {ptr, "Queue", _} -> true;
    _                 -> false
  end.
put_post(_S, [_, InsertedValue], ReturnValue) ->
  ReturnValue == InsertedValue.
get_post(S, _Arguments, ReturnValue) ->
  ReturnValue == hd(S#state.elements).
\end{lstlisting}

To be able to test these properties QuickCheck needs to know how to generate
arguments for every functions.
\begin{lstlisting}
new_args(_S) ->
   [nat()].
put_args(S) ->
   [S#state.ptr, int()].
get_args(S) ->
   [S#state.ptr].
\end{lstlisting}
The functions \lstinline!nat()! and \lstinline!int()! are generators
defined by QuickCheck to generate arbitrary natural numbers and integers.

To test the functions \emph{put}, \emph{get} and \emph{new} defined in the C-code a QuickCheck
property is written in the following way.  \lstset{style=erlang}
\begin{lstlisting}
prop() ->
  ?FORALL(Cmds, commands(),
          begin
            ... = run_commands(Cmds)
          end).
\end{lstlisting}

The function \emph{commands()} is a generator that looks
for functions defining the API-calls, such as \emph{new}, \emph{put} and
\emph{get}, in the Erlang module. The \emph{commands()} function then combines
every function $api_i$ defining an API-call with a function $arg_i$ which
generates the arguments to $api_i$.

After the property has been implemented, it can be tested by:

\begin{lstlisting}
eqc:quickcheck(prop()).
\end{lstlisting}

It is possible define how many tests QuickCheck should execute and also if the
states of the model should be shown:
\begin{lstlisting}
eqc:quickcheck(eqc:numtests(N, eqc_statem:show_states(prop()))).
\end{lstlisting}

\section{QuickCheck Modules}
QuickCheck consist of several Erlang modules.
%%eqc
\subsection{eqc}
The module \emph{eqc} is the main QuickCheck module. This module defines a lot
of macros that can be used when writing properties and also basic functions
like \emph{quickcheck}.

\subsection{eqc\_gen} The module is used for generation of test cases. The module
contains various functions and macros for this purpose. There are some
predefined generators, for instance for integers and characters etcetera, but it
is quite easy to construct a generator for almost any data type. Just to get the
idea follows code for a string generator.
\begin{lstlisting}
    ?LET(Pat, nat(), vector(Pat, char()))
\end{lstlisting}
The macro \emph{?LET} binds a generated value from the second argument, to \emph{Pat} which can be
used in the third argument. The above code binds a natural number, from the
generator \emph{nat()}, to \emph{Pat} and creates a vector with length
\emph{Pat} of characters.

A generator can also be weighted, or in other words certain values can be more
likely to be generated than others.

\begin{lstlisting}
?LET(Pat, nat(), vector(Pat,
                        frequency([{1, choose(0,127)},
                                   {3, 32}])))
\end{lstlisting}
The code above will also generate a string of length \emph{Pat}, but the
generation of the white space character will be 3 times more likely to happen
than a uniformly random character.

%%% eqc_c
\subsection{eqc\_c} Contains the C-testing interface. In other words how to
communicate with C-code.

\begin{lstlisting}
eqc_c:start(q, [{c_src, "q_api.h"},
                {additional_files, ["queue.o"]}])
\end{lstlisting}
The code above starts the C-program \emph{queue.o}, and an Erlang module is
created with the name of the first parameter, \emph{q}. This module can now
be used within Erlang to call the C-program.

%%% eqc_statem
\subsection{eqc\_statem}
\label{SEC:EQC_STATEM}
Offers state based testing as shown above. A command has a definition, precondition,
postcondition, and a next function.

Noticeable is that only the post function may depend on the
C-code. QuickCheck has a generation step where tests are generated
according to the precondition and the model state. The C-code is run
first after the generation step and can only be used to check
postconditions. This is actually what one want because it would be
pointless to execute a program and then test it depending on the
execution of the same program and not the model itself. For instance
if we let the next state function depend on the C-program, then the
model will be faulty if the C-program has incorrect behavior.

Possible preconditions for queue example above could be that the
functions \emph{put} and \emph{get} can only be called if
the queue has first been created and \emph{new} can only be
called with a size greater than zero.
\begin{lstlisting}
new_pre(_S, [Size]) ->
  Size > 0.
put_pre(S) ->
  (S#state.ptr /= undefined) andalso
  (length(S#state.queue) < S#state.size).
get_pre(S) ->
  (S#state.ptr /= undefined) andalso
  (length(S#state.queue) > 0).
\end{lstlisting}

%car_xml
\subsection{car\_xml}
Additional to the commercial version, there is a \emph{car} module. This module is
specifically created to parse AUTOSAR XML configuration files.

%% relevans?
\subsection{Other modules}
\label{APP:SEC:OTHERMODULES}
There are also other modules; for instance a module for mocking C-code. Or in
other words, if one has a C-function that is declared but the
definition is missing, one can simulate its output. This is
however not used in this thesis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{The Watchdog Manager (WdgM)}
\label{APPENDIX:WDGM}
The watchdog is a basic AUTOSAR module. It's purpose is to supervise a programs
execution by triggering hardware watchdogs entities. For the hole description of
the module see the AUTOSAR specification.

\section{Supervision, Checkpoints and Graphs}
The watchdog supervises the execution of so called \emph{Supervised Entities}.
Important places in a supervised entity are marked as checkpoints. There are at
least one checkpoint for every supervised entity. The checkpoints and
transitions between checkpoints are defined as graphs. Checkpoints and
transitions between checkpoints within a given supervised entity are marked as
internal graphs. There may however be transitions between checkpoints of
different supervised entities, such graphs are marked as external graphs.
Available graphs are supplied by the configuration. There may be different
graphs for different modes of the watchdog manager.
%Lite matematiska utryck kanske?

There are three supervision algorithms to verify the correctness of supervised
entities.
\begin{itemize}
\item Logical Supervision: \\
Logical supervision verifies if graphs are executed in the correct order. \\ Let
$G = (V,E)$ be a internal graph for a supervised entity $S$ such that $\forall c_k
\in V \rightarrow c_i \in S$. For the graph $G$ there exist a start checkpoint
$c_s \in V$ and a final checkpoint $c_f \in V$. The logical supervision
checks that the first checkpoint $c_1$ that is reached has the property $c_1 =
c_s$ and for every reached checkpoint $c_j$ there exists an edge
$(c_{j-1},c_{j}) \in E, j \neq 1$.
\item Alive Supervision: \\
  Alive supervision periodically verifies the timing of transitions and
checkpoints reached in a graph.
\item Deadline Supervision: \\
  Deadline supervision does the same as alive supervision but aperiodically.
\end{itemize}

\section{Global Status}
\label{APP:GLOBALSTATUS}
The global status represents the current state of the whole watchdog
manager. There are five different statuses.
\begin{itemize}
\item WDGM\_GLOBAL\_STATUS\_DEACTIVATED \\
  The watchdog manager is in a resting state, deactivated, and will not execute
  any supervision functions.
\item WDGM\_GLOBAL\_STATUS\_OK \\
  The watchdog manager is in a correct state.
\item WDGM\_GLOBAL\_STATUS\_FAILED \\
  A failure has occurred for an alive supervision and the watchdog is configured
  to have a tolerance against this kind of error.
\item WDGM\_GLOBAL\_STATUS\_EXPIRED \\
  A fault has happened and the watchdog is configured to postpone the error
  reaction. In contradiction to
  \emph{WDGM\_GLOBAL\_STATUS\_FAILED} there is no recovery mechanism for this
  state and the watchdog manager will eventually reach the state
  \emph{WDGM\_GLOBAL\_STATUS\_STOPPED}.
\item WDGM\_GLOBAL\_STATUS\_STOPPED \\
  This is an absorbing state of the watchdog state machine. Recovery mechanisms
  will be started and usually a watchdog reset will occur.
\end{itemize}
The different statuses are related to each other according to figure~\ref{APP:FIG:GLOBALSTATUS}.
There is only a small number of functions that is allowed to change the global
status; those are the main function, the initialization function and the
de-initialization function. The main function decide the next global status by
checking the local statuses of the supervised entities and the current global
status. The initialization function should only be able to change the global
status from deactivated to ok, and the de-initialization function from ok to deactivated.

\begin{figure}[!ht]
  \includegraphics{pictures/globalstatuses}
  \label{APP:FIG:GLOBALSTATUS}
  \caption{The possible global statuses represented as a graph}
\end{figure}

\section{Local Status}
A local status is a status of one supervised entity and could be set according
to the current local status and the results of the supervision functions. There
are four different local statuses. Init setmode mainfunction

\begin{itemize}
  \item WDGM\_LOCAL\_STATUS\_DEACTIVATED\\
    If a supervised entity is set to deactivated, it will not be checked by the
    supervision functions.
  \item WDGM\_LOCAL\_STATUS\_OK\\
    The supervised entity is in a correct state.
  \item WDGM\_LOCAL\_STATUS\_FAILED\\
    Alive supervision for the supervised function has failed.
  \item WDGM\_LOCAL\_STATUS\_EXPIRED\\
    A fault has been observed within the supervised function. The main function
    will save the identification of the first supervised entity which reach this
    state.
\end{itemize}
Figure \ref{APP:FIG:LOCALSTATUSES} describes the state machine for the local
status of a supervised entity.

\begin{figure}[!ht]
\includegraphics{pictures/localstatuses}
\label{APP:FIG:LOCALSTATUSES}
\caption{The possible local statuses represented as a graph}
\end{figure}

\section{API functions}
\label{APP:API_CALLS}
\subsection{WdgM\_Init}
Initializes the watchdog manager by setting, among other things, the local
status of all supervised entities to either WDGM\_LOCAL\_STATUS\_OK or
WDGM\_LOCAL\_STATUS\_DEACTIVATED. It also changes the global status to
WDGM\_GLOBAL\_STATUS\_OK.
\subsection{WdgM\_DeInit}
De initializes the watchdog manger.
\subsection{WdgM\_GetVersionInfo}
Returns the version info of the watchdog manager module.\footnote{The function shall not change the
internal state of the watchdog manager and should be side effect free.}
\subsection{WdgM\_SetMode}
Sets a new mode for the watchdog manager.
\subsection{WdgM\_GetMode}
Returns the current mode for the watchdog manager\footnotemark[\thefootnote].
\subsection{WdgM\_CheckpointReached}
\label{SEC:CHECKPOINTREACHED}
Performs deadline and logical supervision for a given supervised entity.
\subsection{WdgM\_GetLocalStatus}
Returns the local status of a supervised entity\footnotemark[\thefootnote].
\subsection{WdgM\_GetGlobalStatus}
Return the global status of the watchdog manager\footnotemark[\thefootnote].
\subsection{WdgM\_PerformReset}
Shall set the trigger condition for all configured watchdogs to zero and
thereby causing the hardware watchdogs to cause an external hardware reset.
\subsection{WdgM\_GetFirstExpiredSEID.}
Returns the supervised entity that first reached the state
\emph{WDGM\_LOCAL\_STATUS\_EXPIRED}\footnotemark[\thefootnote].
\subsection{WdgM\_MainFunction}
\label{SEC:MAINFUNCTION}
The main function is periodically called, it first updates the local statuses by
running alive supervision for the supervised entities and then sets the global
status depending on the current state of the watchdog manager; this includes the
new values of the local statuses.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Bugs in C-code}
%% \section{-Some summary-}
%%   A longer summary with AUTOSAR requirements which is violated
%% \subsection{Severity:}\\
%%   Why?
%% \subsection{Steps to reproduce:}
%%   \begin{lstlistings}
%%     WdgM_Init
%%   \end{lstlistings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Ambiguities in AUTOSAR}
\subsection*{Bad transition}
[WDGM285] claims that ``if \lstinline!WdgM_Init! was successfully called, change
global supervision status to \lstinline!WDGM_GLOBAL_STATUS_OK!''.

[WDGM139] claims that ``if a call to \lstinline!WdgIf_SetMode! fails,
the function shall assume a global supervision failure and set the
global supervision status to \lstinline!WDGM_GLOBAL_STATUS_STOPPED!'',
with a reference to the transition between
\lstinline!WDGM_GLOBAL_STATUS_OK! and stopped.

What if it were not successfully called?

If \lstinline!WdgIf_SetMode! is not successfully called, how can
\lstinline!WdgM_Init! be successfully, and get the global status
\lstinline!WDGM_GLOBAL_STATUS_OK!?


\subsection*{Incorrect reference}
[WDGM329] could be the same as [WDGM273]
The only difference is a parenthesis referencing to Initial/Final?

\subsection*{Optional or mandatory}
[WDGM344] and [WDGM258] is the same, with one difference: one is optional, the
other mandatory.

\subsection*{Logical supervision results}
AUTOSAR does not specify if it is possible to overwrite logical supervision
results from the same supervised entity.
I.e.
\begin{lstlisting}
WdgM_CheckpointReached(SEx, Bad_CP)  -> incorrect result for SEx
WdgM_CheckpointReached(SEx, Good_CP) -> Correct result for SEx
\end{lstlisting}

\subsection*{Wrong spelling}
[WDGM344\_CONF] WdgMInternallCheckpointFinalRef has incorrect
spelling.

[WDGM315] ``set its Results of Active, Deadline and Logical Supervision'',
what is ``Active supervision''? Should be alive supervision.

\subsection*{Retain state}
[WDGM182] if \lstinline!WdgM_SetMode! is called, and a supervised
entity which was activated in the previous mode, also is active in the
new mode, then retain the state for the supervised entity.

The problem is that it is unclear what the supervised entity state
should contain. We know that the status, the results of alive,
deadline and logical supervision and some counters should be part of
this state. Should the supervision functions be part of the state?

This could be problematic because then there is a need to map out
which supervision function should be retained (exists in the new mode
as well as the old mode), which should be discarded (does not exist
in the new mode) and which should be created (exists in the new mode
but not the old).

If it is not part of the state, then all supervisions functions should
be discarded and the new supervision functions should be added.
This could also be problematic because, what if there exist a
supervision function which has the status \lstinline!WDGM_INCORRECT!
and the only thing that keeps the supervised entity from setting the
status \lstinline!WDGM_LOCAL_STATUS_EXPIRED! is a call to
\lstinline!WdgM_MainFunction!. Then a call to \lstinline!WdgM_SetMode!
with the same mode could reset all supervision functions and the
expired state would not happen.

Another question arises; should internal logical supervision functions
count?
They are mode independent, but if the supervised entity is
deactivated, the internal logical supervision should not be able to do anything.

%% \subsection*{Definition of time in deadline supervision}
